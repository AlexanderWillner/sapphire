diff --git a/spm-cli/src/cli/info.rs b/spm-cli/src/cli/info.rs
index 7dd5ca1..2cb10a7 100644
--- a/spm-cli/src/cli/info.rs
+++ b/spm-cli/src/cli/info.rs
@@ -84,7 +84,8 @@ pub async fn get_formula_info(name: &str, _config: &Config, cache: Arc<Cache>) -
     let raw_info = get_formula_info_raw(Arc::clone(&cache), name).await?;
     // Replace map_err closure with direct conversion since SpmError implements
     // From<serde_json::Error>
-    let formula: Formula = serde_json::from_value(raw_info).map_err(SpmError::Json)?;
+    let formula: Formula =
+        serde_json::from_value(raw_info).map_err(|e| SpmError::Json(Arc::new(e)))?;
     Ok(formula)
 }
 
diff --git a/spm-cli/src/cli/install/mod.rs b/spm-cli/src/cli/install/mod.rs
index b53afd2..70b2332 100644
--- a/spm-cli/src/cli/install/mod.rs
+++ b/spm-cli/src/cli/install/mod.rs
@@ -87,7 +87,7 @@ async fn load_or_fetch_json(
             }
             serde_json::from_str(&raw_data).map_err(|e| {
                 error!("Failed to parse API response for {}: {}", filename, e);
-                SpmError::Json(e)
+                SpmError::Json(Arc::new(e))
             })
         }
     }
diff --git a/spm-cli/src/cli/uninstall.rs b/spm-cli/src/cli/uninstall.rs
index 965b221..17e82ed 100644
--- a/spm-cli/src/cli/uninstall.rs
+++ b/spm-cli/src/cli/uninstall.rs
@@ -116,10 +116,10 @@ impl Uninstall {
 
                 tracing::debug!("Removing formula keg directory: {}", cellar_path.display());
                 if let Err(e) = fs::remove_dir_all(&cellar_path) {
-                    let removal_error = SpmError::Io(std::io::Error::new(
+                    let removal_error = SpmError::Io(Arc::new(std::io::Error::new(
                         e.kind(),
                         format!("Failed remove keg {}: {}", cellar_path.display(), e),
-                    ));
+                    )));
                     tracing::error!("{}", removal_error);
                     errors.push((name.to_string(), removal_error));
                     pb.finish_and_clear();
@@ -148,7 +148,7 @@ impl Uninstall {
                         Ok(c) => c,
                         Err(e) => {
                             tracing::error!("Failed to parse cask JSON for {}: {}", name, e);
-                            errors.push((name.to_string(), SpmError::Json(e)));
+                            errors.push((name.to_string(), SpmError::Json(Arc::new(e))));
                             pb.finish_and_clear();
                             continue;
                         }
@@ -276,10 +276,10 @@ impl Uninstall {
                         );
                         errors.push((
                             name.to_string(),
-                            SpmError::Io(std::io::Error::new(
+                            SpmError::Io(Arc::new(std::io::Error::new(
                                 e.kind(),
                                 format!("Failed to remove cask version dir for '{name}'"),
-                            )),
+                            ))),
                         ));
                         // If dir removal fails, stop processing this cask.
                         pb.finish_and_clear();
diff --git a/spm-core/src/build/cask/artifacts/app.rs b/spm-core/src/build/cask/artifacts/app.rs
index 734e8dc..2694d59 100644
--- a/spm-core/src/build/cask/artifacts/app.rs
+++ b/spm-core/src/build/cask/artifacts/app.rs
@@ -86,7 +86,7 @@ pub fn install_app_from_staged(
                     final_app_destination.display(),
                     e
                 );
-                return Err(SpmError::Io(e));
+                return Err(SpmError::Io(std::sync::Arc::new(e)));
             }
         } else {
             debug!("Successfully removed existing app.");
diff --git a/spm-core/src/build/cask/artifacts/pkg.rs b/spm-core/src/build/cask/artifacts/pkg.rs
index ada0385..3fba703 100644
--- a/spm-core/src/build/cask/artifacts/pkg.rs
+++ b/spm-core/src/build/cask/artifacts/pkg.rs
@@ -41,10 +41,10 @@ pub fn install_pkg_from_path(
     );
     if let Some(parent) = caskroom_pkg_path.parent() {
         fs::create_dir_all(parent).map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!("Failed create parent dir {}: {}", parent.display(), e),
-            ))
+            )))
         })?;
     }
     if let Err(e) = fs::copy(pkg_path, &caskroom_pkg_path) {
@@ -54,10 +54,10 @@ pub fn install_pkg_from_path(
             caskroom_pkg_path.display(),
             e
         );
-        return Err(SpmError::Io(std::io::Error::new(
+        return Err(SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed copy PKG to caskroom: {e}"),
-        )));
+        ))));
     } else {
         // Record the reference copy artifact
         installed_artifacts.push(InstalledArtifact::CaskroomReference {
@@ -79,10 +79,10 @@ pub fn install_pkg_from_path(
         .arg("/")
         .output()
         .map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!("Failed to execute sudo installer: {e}"),
-            ))
+            )))
         })?;
 
     if !output.status.success() {
diff --git a/spm-core/src/build/cask/dmg.rs b/spm-core/src/build/cask/dmg.rs
index d8f61ad..a722927 100644
--- a/spm-core/src/build/cask/dmg.rs
+++ b/spm-core/src/build/cask/dmg.rs
@@ -156,7 +156,7 @@ pub fn extract_dmg_to_stage(dmg_path: &Path, stage_dir: &Path) -> Result<()> {
 
     // Ensure the stage directory exists (though TempDir should handle it)
     if !stage_dir.exists() {
-        fs::create_dir_all(stage_dir).map_err(SpmError::Io)?;
+        fs::create_dir_all(stage_dir).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
     }
 
     debug!(
diff --git a/spm-core/src/build/cask/mod.rs b/spm-core/src/build/cask/mod.rs
index 281a862..076f152 100644
--- a/spm-core/src/build/cask/mod.rs
+++ b/spm-core/src/build/cask/mod.rs
@@ -102,7 +102,7 @@ pub async fn download_cask(cask: &Cask, cache: &Cache) -> Result<PathBuf> {
         .get(parsed.clone())
         .send()
         .await
-        .map_err(SpmError::Http)?;
+        .map_err(|e| SpmError::Http(std::sync::Arc::new(e)))?;
     if !response.status().is_success() {
         return Err(SpmError::DownloadError(
             cask.token.clone(),
@@ -110,7 +110,10 @@ pub async fn download_cask(cask: &Cask, cache: &Cache) -> Result<PathBuf> {
             format!("HTTP status {}", response.status()),
         ));
     }
-    let bytes = response.bytes().await.map_err(SpmError::Http)?;
+    let bytes = response
+        .bytes()
+        .await
+        .map_err(|e| SpmError::Http(std::sync::Arc::new(e)))?;
     if let Some(parent) = cache_path.parent() {
         fs::create_dir_all(parent)?;
     }
@@ -149,14 +152,14 @@ pub fn install_cask(cask: &Cask, download_path: &Path, config: &Config) -> Resul
     let cask_version_install_path = get_cask_version_path(cask, config);
     if !cask_version_install_path.exists() {
         fs::create_dir_all(&cask_version_install_path).map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!(
                     "Failed create cask dir {}: {}",
                     cask_version_install_path.display(),
                     e
                 ),
-            ))
+            )))
         })?;
         debug!(
             "Created cask version directory: {}",
@@ -196,7 +199,7 @@ pub fn install_cask(cask: &Cask, download_path: &Path, config: &Config) -> Resul
                     download_path.display(),
                     e
                 );
-                return Err(SpmError::Io(e));
+                return Err(SpmError::Io(std::sync::Arc::new(e)));
             }
         }
     } else {
@@ -227,10 +230,10 @@ pub fn install_cask(cask: &Cask, download_path: &Path, config: &Config) -> Resul
         }
     }
     let stage_dir = TempDir::new().map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed to create staging directory: {e}"),
-        ))
+        )))
     })?;
     let stage_path = stage_dir.path();
     debug!("Created staging directory: {}", stage_path.display());
@@ -593,10 +596,12 @@ pub fn write_receipt(
         "artifacts_installed": artifacts
     });
     if let Some(parent) = receipt_path.parent() {
-        fs::create_dir_all(parent).map_err(SpmError::Io)?;
+        fs::create_dir_all(parent).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
     }
-    let mut file = fs::File::create(&receipt_path).map_err(SpmError::Io)?;
-    serde_json::to_writer_pretty(&mut file, &receipt_data).map_err(SpmError::Json)?;
+    let mut file =
+        fs::File::create(&receipt_path).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
+    serde_json::to_writer_pretty(&mut file, &receipt_data)
+        .map_err(|e| SpmError::Json(std::sync::Arc::new(e)))?;
     debug!(
         "Successfully wrote legacy receipt with {} artifact entries.",
         artifacts.len()
@@ -624,17 +629,17 @@ pub fn write_cask_manifest(
     };
     if let Some(parent) = manifest_path.parent() {
         fs::create_dir_all(parent).map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!("Failed create parent dir {}: {}", parent.display(), e),
-            ))
+            )))
         })?;
     }
     let file = fs::File::create(&manifest_path).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed create manifest {}: {}", manifest_path.display(), e),
-        ))
+        )))
     })?;
     let writer = std::io::BufWriter::new(file);
     serde_json::to_writer_pretty(writer, &manifest_data).map_err(|e| {
@@ -642,7 +647,7 @@ pub fn write_cask_manifest(
             "Failed to serialize cask manifest JSON for {}: {}",
             cask.token, e
         );
-        SpmError::Json(e)
+        SpmError::Json(std::sync::Arc::new(e))
     })?;
     debug!(
         "Successfully wrote cask manifest with {} artifact entries.",
diff --git a/spm-core/src/build/extract.rs b/spm-core/src/build/extract.rs
index a3d539a..0dc541b 100644
--- a/spm-core/src/build/extract.rs
+++ b/spm-core/src/build/extract.rs
@@ -23,10 +23,10 @@ pub(crate) fn infer_archive_root_dir(
         archive_path.display()
     );
     let file = File::open(archive_path).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed to open archive {}: {}", archive_path.display(), e),
-        ))
+        )))
     })?;
 
     match archive_type {
@@ -230,24 +230,24 @@ pub fn extract_archive(
 		archive_path.display(), archive_type, target_dir.display(), strip_components);
 
     fs::create_dir_all(target_dir).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!(
                 "Failed to create target directory {}: {}",
                 target_dir.display(),
                 e
             ),
-        ))
+        )))
     })?;
 
     let temp_extract_dir = tempfile::Builder::new()
         .prefix(".extract-")
         .tempdir_in(target_dir)
         .map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!("Failed create temp extract dir: {e}"),
-            ))
+            )))
         })?;
     let temp_extract_path = temp_extract_dir.path();
     debug!(
@@ -256,10 +256,10 @@ pub fn extract_archive(
     );
 
     let file = File::open(archive_path).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed to open archive {}: {}", archive_path.display(), e),
-        ))
+        )))
     })?;
 
     match archive_type {
@@ -293,14 +293,16 @@ pub fn extract_archive(
         "Validating extracted contents in {}",
         temp_extract_path.display()
     );
-    let abs_temp_extract_path = temp_extract_path.canonicalize().map_err(SpmError::Io)?;
+    let abs_temp_extract_path = temp_extract_path
+        .canonicalize()
+        .map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
 
     for entry_result in WalkDir::new(temp_extract_path) {
         let entry = entry_result.map_err(|e| {
-            SpmError::Io(
+            SpmError::Io(std::sync::Arc::new(
                 e.into_io_error()
                     .unwrap_or_else(|| std::io::Error::other("Walkdir error")),
-            )
+            ))
         })?;
         let path = entry.path();
 
@@ -330,15 +332,18 @@ pub fn extract_archive(
         }
 
         if entry.file_type().is_symlink() {
-            let link_target = fs::read_link(path).map_err(SpmError::Io)?;
+            let link_target =
+                fs::read_link(path).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
             let link_parent = path.parent().unwrap_or(path);
             let resolved_target_abs = if link_target.is_absolute() {
-                link_target.canonicalize().map_err(SpmError::Io)?
+                link_target
+                    .canonicalize()
+                    .map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?
             } else {
                 link_parent
                     .join(&link_target)
                     .canonicalize()
-                    .map_err(SpmError::Io)?
+                    .map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?
             };
 
             if !resolved_target_abs.starts_with(&abs_temp_extract_path) {
@@ -371,7 +376,8 @@ pub fn extract_archive(
         let item = item_result?;
         let source_item_path = item.path();
         let dest_item_path = target_dir.join(item.file_name());
-        fs::rename(&source_item_path, &dest_item_path).map_err(SpmError::Io)?;
+        fs::rename(&source_item_path, &dest_item_path)
+            .map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
     }
     Ok(())
 }
@@ -466,10 +472,10 @@ fn extract_tar_archive<R: Read>(
         if let Some(parent) = target_path.parent() {
             if !parent.exists() {
                 fs::create_dir_all(parent).map_err(|e| {
-                    SpmError::Io(io::Error::new(
+                    SpmError::Io(std::sync::Arc::new(io::Error::new(
                         e.kind(),
                         format!("Failed create parent dir {}: {}", parent.display(), e),
-                    ))
+                    )))
                 })?;
             }
         }
@@ -580,10 +586,10 @@ fn extract_zip_archive<R: Read + Seek>(
         if let Some(parent) = target_path.parent() {
             if !parent.exists() {
                 fs::create_dir_all(parent).map_err(|e| {
-                    SpmError::Io(io::Error::new(
+                    SpmError::Io(std::sync::Arc::new(io::Error::new(
                         e.kind(),
                         format!("Failed create dir {}: {}", parent.display(), e),
-                    ))
+                    )))
                 })?;
             }
         }
@@ -591,10 +597,10 @@ fn extract_zip_archive<R: Read + Seek>(
         if file.is_dir() {
             if !target_path.exists() {
                 fs::create_dir_all(&target_path).map_err(|e| {
-                    SpmError::Io(io::Error::new(
+                    SpmError::Io(std::sync::Arc::new(io::Error::new(
                         e.kind(),
                         format!("Failed create dir {}: {}", target_path.display(), e),
-                    ))
+                    )))
                 })?;
             }
         } else if file.is_symlink() {
@@ -613,7 +619,7 @@ fn extract_zip_archive<R: Read + Seek>(
                         link_target.display(),
                         e
                     );
-                    SpmError::Io(e)
+                    SpmError::Io(std::sync::Arc::new(e))
                 })?;
             }
             #[cfg(not(unix))]
@@ -629,10 +635,10 @@ fn extract_zip_archive<R: Read + Seek>(
                 let _ = fs::remove_file(&target_path);
             }
             let mut out_file = File::create(&target_path).map_err(|e| {
-                SpmError::Io(io::Error::new(
+                SpmError::Io(std::sync::Arc::new(io::Error::new(
                     e.kind(),
                     format!("Failed create file {}: {}", target_path.display(), e),
-                ))
+                )))
             })?;
             io::copy(&mut file, &mut out_file)?;
         }
diff --git a/spm-core/src/build/formula/bottle.rs b/spm-core/src/build/formula/bottle.rs
index 89db879..0cb8dbb 100644
--- a/spm-core/src/build/formula/bottle.rs
+++ b/spm-core/src/build/formula/bottle.rs
@@ -41,7 +41,7 @@ pub async fn download_bottle(
         formula.name, standard_version_str, platform_tag
     );
     let cache_dir = config.cache_dir.join("bottles");
-    fs::create_dir_all(&cache_dir).map_err(SpmError::Io)?;
+    fs::create_dir_all(&cache_dir).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
     let bottle_cache_path = cache_dir.join(&filename);
     if bottle_cache_path.is_file() {
         debug!("Bottle found in cache: {}", bottle_cache_path.display());
@@ -308,14 +308,14 @@ pub fn install_bottle(bottle_path: &Path, formula: &Formula, config: &Config) ->
     }
     if let Some(parent_dir) = install_dir.parent() {
         fs::create_dir_all(parent_dir).map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!(
                     "Failed to create parent dir {}: {}",
                     parent_dir.display(),
                     e
                 ),
-            ))
+            )))
         })?;
     } else {
         return Err(SpmError::InstallError(format!(
@@ -324,10 +324,10 @@ pub fn install_bottle(bottle_path: &Path, formula: &Formula, config: &Config) ->
         )));
     }
     fs::create_dir_all(&install_dir).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed to create keg dir {}: {}", install_dir.display(), e),
-        ))
+        )))
     })?;
     let strip_components = 2;
     debug!(
@@ -699,7 +699,7 @@ fn write_text_file_atomic(original_path: &Path, content: &str) -> Result<()> {
             original_path.display(),
             e.error
         );
-        SpmError::Io(e.error)
+        SpmError::Io(std::sync::Arc::new(e.error))
     })?;
     if let Some(perms) = original_perms {
         let _ = fs::set_permissions(original_path, perms);
diff --git a/spm-core/src/build/formula/link.rs b/spm-core/src/build/formula/link.rs
index f295743..167c4d3 100644
--- a/spm-core/src/build/formula/link.rs
+++ b/spm-core/src/build/formula/link.rs
@@ -37,10 +37,10 @@ pub fn link_formula_artifacts(
 
     remove_existing_link_target(&opt_link_path)?;
     unix_fs::symlink(target_keg_dir, &opt_link_path).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed to create opt symlink for {}: {}", formula.name(), e),
-        ))
+        )))
     })?;
     symlinks_created.push(opt_link_path.to_string_lossy().to_string());
     debug!(
@@ -273,16 +273,16 @@ fn create_wrapper_script(
     ));
 
     let mut file = fs::File::create(wrapper_path).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed create wrapper {}: {}", wrapper_path.display(), e),
-        ))
+        )))
     })?;
     file.write_all(script_content.as_bytes()).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed write wrapper {}: {}", wrapper_path.display(), e),
-        ))
+        )))
     })?;
 
     #[cfg(unix)]
@@ -291,14 +291,14 @@ fn create_wrapper_script(
         let mut permissions = metadata.permissions();
         permissions.set_mode(0o755);
         fs::set_permissions(wrapper_path, permissions).map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!(
                     "Failed set wrapper executable {}: {}",
                     wrapper_path.display(),
                     e
                 ),
-            ))
+            )))
         })?;
     }
 
@@ -419,7 +419,7 @@ fn remove_existing_link_target(path: &Path) -> Result<()> {
                     path.display(),
                     e
                 );
-                return Err(SpmError::Io(e));
+                return Err(SpmError::Io(std::sync::Arc::new(e)));
             }
             Ok(())
         }
@@ -430,7 +430,7 @@ fn remove_existing_link_target(path: &Path) -> Result<()> {
                 path.display(),
                 e
             );
-            Err(SpmError::Io(e))
+            Err(SpmError::Io(std::sync::Arc::new(e)))
         }
     }
 }
@@ -453,12 +453,12 @@ fn write_install_manifest(installed_keg_path: &Path, symlinks_created: &[String]
                     manifest_path.display(),
                     e
                 );
-                return Err(SpmError::Io(e));
+                return Err(SpmError::Io(std::sync::Arc::new(e)));
             }
         },
         Err(e) => {
             error!("Failed to serialize install manifest data: {}", e);
-            return Err(SpmError::Json(e));
+            return Err(SpmError::Json(std::sync::Arc::new(e)));
         }
     }
     Ok(())
@@ -786,7 +786,7 @@ fn unlink_executables_from_dir(source_exec_dir: &Path, target_link_dir: &Path) -
                 source_exec_dir.display(),
                 e
             );
-            return Err(SpmError::Io(e));
+            return Err(SpmError::Io(std::sync::Arc::new(e)));
         }
     }
     Ok(unlinked_count)
@@ -799,7 +799,7 @@ fn is_executable(path: &Path) -> Result<bool> {
         use std::os::unix::fs::PermissionsExt;
         match fs::metadata(path) {
             Ok(metadata) => Ok(metadata.permissions().mode() & 0o111 != 0),
-            Err(e) => Err(SpmError::Io(e)),
+            Err(e) => Err(SpmError::Io(std::sync::Arc::new(e))),
         }
     } else {
         Ok(true)
@@ -844,7 +844,7 @@ fn is_symlink_to(link: &Path, target: &Path) -> Result<bool> {
                 },
                 Err(e) => {
                     debug!("Failed to read link target for {}: {}", link.display(), e);
-                    Err(SpmError::Io(e))
+                    Err(SpmError::Io(std::sync::Arc::new(e)))
                 }
             }
         }
@@ -855,7 +855,7 @@ fn is_symlink_to(link: &Path, target: &Path) -> Result<bool> {
                 link.display(),
                 e
             );
-            Err(SpmError::Io(e))
+            Err(SpmError::Io(std::sync::Arc::new(e)))
         }
     }
 }
diff --git a/spm-core/src/build/formula/macho.rs b/spm-core/src/build/formula/macho.rs
index 4bf10ca..6e78099 100644
--- a/spm-core/src/build/formula/macho.rs
+++ b/spm-core/src/build/formula/macho.rs
@@ -419,7 +419,7 @@ fn write_patched_buffer(original_path: &Path, buffer: &[u8]) -> Result<()> {
         ))
     })?;
     // Ensure the directory exists
-    fs::create_dir_all(dir).map_err(SpmError::Io)?;
+    fs::create_dir_all(dir).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
 
     // Create a named temporary file in the same directory to facilitate atomic rename
     let mut temp_file = NamedTempFile::new_in(dir)?;
@@ -446,7 +446,7 @@ fn write_patched_buffer(original_path: &Path, buffer: &[u8]) -> Result<()> {
             e.error // Log the underlying IO error
         );
         // Return the IO error wrapped in our error type
-        SpmError::Io(e.error)
+        SpmError::Io(std::sync::Arc::new(e.error))
     })?;
     debug!(
         "    Atomically replaced {} with patched version",
@@ -477,7 +477,7 @@ fn resign_binary(path: &Path) -> Result<()> {
                 path.display(),
                 e
             );
-            SpmError::Io(e)
+            SpmError::Io(std::sync::Arc::new(e))
         })?;
     if status.success() {
         // Suppressed: debug!("Successfully re-signed {}", path.display());
diff --git a/spm-core/src/build/formula/mod.rs b/spm-core/src/build/formula/mod.rs
index dc513d4..317fd44 100644
--- a/spm-core/src/build/formula/mod.rs
+++ b/spm-core/src/build/formula/mod.rs
@@ -271,7 +271,7 @@ pub fn write_receipt(formula: &Formula, install_dir: &Path) -> Result<()> {
                 receipt_path.display(),
                 e
             );
-            return Err(SpmError::Io(e));
+            return Err(SpmError::Io(std::sync::Arc::new(e)));
         }
     };
 
@@ -306,13 +306,13 @@ pub fn write_receipt(formula: &Formula, install_dir: &Path) -> Result<()> {
                 "Failed to serialize receipt JSON for {}: {}",
                 formula.name, e
             );
-            return Err(SpmError::Json(e));
+            return Err(SpmError::Json(std::sync::Arc::new(e)));
         }
     };
 
     if let Err(e) = receipt_file.write_all(receipt_json.as_bytes()) {
         error!("Failed to write receipt file for {}: {}", formula.name, e);
-        return Err(SpmError::Io(e));
+        return Err(SpmError::Io(std::sync::Arc::new(e)));
     }
 
     Ok(())
diff --git a/spm-core/src/build/formula/source/cmake.rs b/spm-core/src/build/formula/source/cmake.rs
index 5851562..1fde5b2 100644
--- a/spm-core/src/build/formula/source/cmake.rs
+++ b/spm-core/src/build/formula/source/cmake.rs
@@ -19,7 +19,7 @@ pub fn cmake_build(
     debug!("Building with CMake in {}", build_dir.display());
     let cmake_build_subdir_name = "spm-cmake-build";
     let cmake_build_dir = build_dir.join(cmake_build_subdir_name);
-    fs::create_dir_all(&cmake_build_dir).map_err(SpmError::Io)?;
+    fs::create_dir_all(&cmake_build_dir).map_err(|e| SpmError::Io(std::sync::Arc::new(e)))?;
 
     let cmake_exe =
         which::which_in("cmake", build_env.get_path_string(), build_dir).map_err(|_| {
diff --git a/spm-core/src/build/formula/source/go.rs b/spm-core/src/build/formula/source/go.rs
index bb80710..bddef90 100644
--- a/spm-core/src/build/formula/source/go.rs
+++ b/spm-core/src/build/formula/source/go.rs
@@ -47,10 +47,10 @@ pub fn go_build(
 
     let target_bin_dir = install_dir.join("bin");
     fs::create_dir_all(&target_bin_dir).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed create target bin dir: {e}"),
-        ))
+        )))
     })?;
     let output_binary_path = target_bin_dir.join(formula_name);
 
diff --git a/spm-core/src/build/formula/source/make.rs b/spm-core/src/build/formula/source/make.rs
index 4fde60a..dd99bd6 100644
--- a/spm-core/src/build/formula/source/make.rs
+++ b/spm-core/src/build/formula/source/make.rs
@@ -199,10 +199,10 @@ pub fn simple_make(
 
             let target_path = bin_dir.join(formula_name);
             fs::copy(&potential_binary_path, &target_path).map_err(|e| {
-                SpmError::Io(std::io::Error::new(
+                SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                     e.kind(),
                     format!("Failed copy binary: {e}"),
-                ))
+                )))
             })?;
 
             #[cfg(unix)]
diff --git a/spm-core/src/build/formula/source/mod.rs b/spm-core/src/build/formula/source/mod.rs
index 50f6668..fc6beb5 100644
--- a/spm-core/src/build/formula/source/mod.rs
+++ b/spm-core/src/build/formula/source/mod.rs
@@ -72,10 +72,10 @@ pub async fn download_source(formula: &Formula, config: &Config) -> Result<PathB
 
 fn create_dir_all_with_context(path: &Path, context: &str) -> Result<()> {
     fs::create_dir_all(path).map_err(|e| {
-        SpmError::Io(std::io::Error::new(
+        SpmError::Io(std::sync::Arc::new(std::io::Error::new(
             e.kind(),
             format!("Failed to create {} {}: {}", context, path.display(), e),
-        ))
+        )))
     })
 }
 
@@ -101,10 +101,10 @@ fn determine_source_root(build_dir: &Path) -> Result<PathBuf> {
             }
         }
         Err(e) => {
-            return Err(SpmError::Io(std::io::Error::new(
+            return Err(SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!("Failed read build dir {}: {}", build_dir.display(), e),
-            )));
+            ))));
         }
     }
 
@@ -435,10 +435,10 @@ pub async fn build_from_source(
     if !install_dir.exists() {
         debug!("Creating installation directory: {}", install_dir.display());
         fs::create_dir_all(&install_dir).map_err(|e| {
-            SpmError::Io(std::io::Error::new(
+            SpmError::Io(std::sync::Arc::new(std::io::Error::new(
                 e.kind(),
                 format!("Failed create install dir: {e}"),
-            ))
+            )))
         })?;
     } else {
         debug!(
diff --git a/spm-core/src/fetch/api.rs b/spm-core/src/fetch/api.rs
index c4dce2a..c7d93cf 100644
--- a/spm-core/src/fetch/api.rs
+++ b/spm-core/src/fetch/api.rs
@@ -1,3 +1,5 @@
+use std::sync::Arc;
+
 use reqwest::header::{ACCEPT, AUTHORIZATION, USER_AGENT};
 use reqwest::Client;
 use serde_json::Value;
@@ -29,10 +31,7 @@ fn build_api_client(config: &Config) -> Result<Client> {
     } else {
         debug!("No GitHub API token found in config.");
     }
-    Client::builder()
-        .default_headers(headers)
-        .build()
-        .map_err(SpmError::Http)
+    Ok(Client::builder().default_headers(headers).build()?)
 }
 
 pub async fn fetch_raw_formulae_json(endpoint: &str) -> Result<String> {
@@ -40,11 +39,10 @@ pub async fn fetch_raw_formulae_json(endpoint: &str) -> Result<String> {
     debug!("Fetching data from Homebrew Formulae API: {}", url);
     let client = reqwest::Client::builder()
         .user_agent(USER_AGENT_STRING)
-        .build()
-        .map_err(SpmError::Http)?;
+        .build()?;
     let response = client.get(&url).send().await.map_err(|e| {
         error!("HTTP request failed for {}: {}", url, e);
-        SpmError::Http(e)
+        SpmError::Http(Arc::new(e))
     })?;
     if !response.status().is_success() {
         let status = response.status();
@@ -59,7 +57,7 @@ pub async fn fetch_raw_formulae_json(endpoint: &str) -> Result<String> {
         debug!("Response body for failed request to {}: {}", url, body);
         return Err(SpmError::Api(format!("HTTP status {status} from {url}")));
     }
-    let body = response.text().await.map_err(SpmError::Http)?;
+    let body = response.text().await?;
     if body.trim().is_empty() {
         error!("Response body for {} was empty.", url);
         return Err(SpmError::Api(format!(
@@ -80,7 +78,7 @@ pub async fn fetch_all_casks() -> Result<String> {
 pub async fn fetch_formula(name: &str) -> Result<serde_json::Value> {
     let direct_fetch_result = fetch_raw_formulae_json(&format!("formula/{name}.json")).await;
     if let Ok(body) = direct_fetch_result {
-        let formula: serde_json::Value = serde_json::from_str(&body).map_err(SpmError::Json)?;
+        let formula: serde_json::Value = serde_json::from_str(&body)?;
         Ok(formula)
     } else {
         debug!(
@@ -107,7 +105,7 @@ pub async fn fetch_formula(name: &str) -> Result<serde_json::Value> {
 pub async fn fetch_cask(token: &str) -> Result<serde_json::Value> {
     let direct_fetch_result = fetch_raw_formulae_json(&format!("cask/{token}.json")).await;
     if let Ok(body) = direct_fetch_result {
-        let cask: serde_json::Value = serde_json::from_str(&body).map_err(SpmError::Json)?;
+        let cask: serde_json::Value = serde_json::from_str(&body)?;
         Ok(cask)
     } else {
         debug!(
@@ -134,7 +132,7 @@ async fn fetch_github_api_json(endpoint: &str, config: &Config) -> Result<Value>
     let client = build_api_client(config)?;
     let response = client.get(&url).send().await.map_err(|e| {
         error!("GitHub API request failed for {}: {}", url, e);
-        SpmError::Http(e)
+        SpmError::Http(Arc::new(e))
     })?;
     if !response.status().is_success() {
         let status = response.status();
@@ -172,54 +170,48 @@ pub async fn get_formula(name: &str) -> Result<Formula> {
         name, url
     );
     let client = reqwest::Client::new();
-    let response_result = client.get(&url).send().await;
-    match response_result {
-        Ok(response) => {
-            let status = response.status();
-            let text = response
-                .text()
-                .await
-                .unwrap_or_else(|e| format!("(Failed to read body: {e})"));
-            if !status.is_success() {
-                error!("Failed to fetch formula {} (Status {})", name, status);
-                debug!("Response body for failed formula fetch {}: {}", name, text);
-                return Err(SpmError::Api(format!(
-                    "Failed to fetch formula {name}: Status {status}"
-                )));
-            }
-            if text.trim().is_empty() {
-                error!("Received empty body when fetching formula {}", name);
-                return Err(SpmError::Api(format!(
-                    "Empty response body for formula {name}"
-                )));
-            }
-            match serde_json::from_str::<Formula>(&text) {
-                Ok(formula) => Ok(formula),
-                Err(_) => match serde_json::from_str::<Vec<Formula>>(&text) {
-                    Ok(mut formulas) if !formulas.is_empty() => {
-                        debug!(
-                            "Parsed formula {} from a single-element array response.",
-                            name
-                        );
-                        Ok(formulas.remove(0))
-                    }
-                    Ok(_) => {
-                        error!("Received empty array when fetching formula {}", name);
-                        Err(SpmError::NotFound(format!(
-                            "Formula '{name}' not found (empty array returned)"
-                        )))
-                    }
-                    Err(e_vec) => {
-                        error!("Failed to parse formula {} as object or array. Error: {}. Body (sample): {}", name, e_vec, text.chars().take(500).collect::<String>());
-                        Err(SpmError::Json(e_vec))
-                    }
-                },
+    let response = client.get(&url).send().await.map_err(|e| {
+        error!("HTTP request failed when fetching formula {}: {}", name, e);
+        SpmError::Http(Arc::new(e))
+    })?;
+    let status = response.status();
+    let text = response.text().await?;
+    if !status.is_success() {
+        error!("Failed to fetch formula {} (Status {})", name, status);
+        debug!("Response body for failed formula fetch {}: {}", name, text);
+        return Err(SpmError::Api(format!(
+            "Failed to fetch formula {name}: Status {status}"
+        )));
+    }
+    if text.trim().is_empty() {
+        error!("Received empty body when fetching formula {}", name);
+        return Err(SpmError::Api(format!(
+            "Empty response body for formula {name}"
+        )));
+    }
+    match serde_json::from_str::<Formula>(&text) {
+        Ok(formula) => Ok(formula),
+        Err(_) => {
+            match serde_json::from_str::<Vec<Formula>>(&text) {
+                Ok(mut formulas) if !formulas.is_empty() => {
+                    debug!(
+                        "Parsed formula {} from a single-element array response.",
+                        name
+                    );
+                    Ok(formulas.remove(0))
+                }
+                Ok(_) => {
+                    error!("Received empty array when fetching formula {}", name);
+                    Err(SpmError::NotFound(format!(
+                        "Formula '{name}' not found (empty array returned)"
+                    )))
+                }
+                Err(e_vec) => {
+                    error!("Failed to parse formula {} as object or array. Error: {}. Body (sample): {}", name, e_vec, text.chars().take(500).collect::<String>());
+                    Err(SpmError::Json(Arc::new(e_vec)))
+                }
             }
         }
-        Err(e) => {
-            error!("HTTP request failed when fetching formula {}: {}", name, e);
-            Err(SpmError::Http(e))
-        }
     }
 }
 
@@ -227,7 +219,7 @@ pub async fn get_all_formulas() -> Result<Vec<Formula>> {
     let raw_data = fetch_all_formulas().await?;
     serde_json::from_str(&raw_data).map_err(|e| {
         error!("Failed to parse all_formulas response: {}", e);
-        SpmError::Json(e)
+        SpmError::Json(Arc::new(e))
     })
 }
 
@@ -257,7 +249,7 @@ pub async fn get_cask(name: &str) -> Result<Cask> {
                     tracing::debug!("Raw problematic value: {:?}", raw_json);
                 }
             }
-            Err(SpmError::Json(e))
+            Err(SpmError::Json(Arc::new(e)))
         }
     }
 }
@@ -266,7 +258,7 @@ pub async fn get_all_casks() -> Result<CaskList> {
     let raw_data = fetch_all_casks().await?;
     let casks: Vec<Cask> = serde_json::from_str(&raw_data).map_err(|e| {
         error!("Failed to parse all_casks response: {}", e);
-        SpmError::Json(e)
+        SpmError::Json(Arc::new(e))
     })?;
     Ok(CaskList { casks })
 }
diff --git a/spm-core/src/fetch/oci.rs b/spm-core/src/fetch/oci.rs
index 94dcf3b..30f5149 100644
--- a/spm-core/src/fetch/oci.rs
+++ b/spm-core/src/fetch/oci.rs
@@ -1,6 +1,7 @@
 use std::collections::HashMap;
 use std::fs::{remove_file, File};
 use std::path::Path;
+use std::sync::Arc;
 use std::time::Duration;
 
 use futures::StreamExt;
@@ -81,12 +82,12 @@ async fn fetch_oci_resource<T: serde::de::DeserializeOwned>(
 
     let auth = determine_auth(config, client, registry_domain, repo_path).await?;
     let resp = execute_oci_request(client, resource_url, accept_header, &auth).await?;
-    let txt = resp.text().await.map_err(SpmError::Http)?;
+    let txt = resp.text().await.map_err(|e| SpmError::Http(Arc::new(e)))?;
 
     debug!("OCI response ({} bytes) from {}", txt.len(), resource_url);
     serde_json::from_str(&txt).map_err(|e| {
         error!("JSON parse error from {}: {}", resource_url, e);
-        SpmError::Json(e)
+        SpmError::Json(Arc::new(e))
     })
 }
 
@@ -111,14 +112,14 @@ pub async fn download_oci_blob(
         ".{}.download",
         destination_path.file_name().unwrap().to_string_lossy()
     ));
-    let mut out = File::create(&tmp).map_err(SpmError::Io)?;
+    let mut out = File::create(&tmp).map_err(|e| SpmError::Io(Arc::new(e)))?;
 
     let mut stream = resp.bytes_stream();
     while let Some(chunk) = stream.next().await {
-        let b = chunk.map_err(SpmError::Http)?;
-        std::io::Write::write_all(&mut out, &b).map_err(SpmError::Io)?;
+        let b = chunk.map_err(|e| SpmError::Http(Arc::new(e)))?;
+        std::io::Write::write_all(&mut out, &b).map_err(|e| SpmError::Io(Arc::new(e)))?;
     }
-    std::fs::rename(&tmp, destination_path).map_err(SpmError::Io)?;
+    std::fs::rename(&tmp, destination_path).map_err(|e| SpmError::Io(Arc::new(e)))?;
 
     if !expected_digest.is_empty() {
         match crate::fetch::validation::verify_checksum(destination_path, expected_digest) {
@@ -160,7 +161,7 @@ pub fn build_oci_client() -> Result<Client> {
         .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
         .redirect(reqwest::redirect::Policy::default())
         .build()
-        .map_err(SpmError::Http)
+        .map_err(|e| SpmError::Http(Arc::new(e)))
 }
 
 fn extract_repo_path_from_url(url: &Url) -> Option<&str> {
@@ -251,7 +252,7 @@ async fn fetch_anonymous_token(
             Err(e) => {
                 error!("Network error on token fetch {}: {}", attempt + 1, e);
                 if attempt == MAX_RETRIES {
-                    return Err(SpmError::Http(e));
+                    return Err(SpmError::Http(Arc::new(e)));
                 }
             }
         }
@@ -287,7 +288,7 @@ async fn execute_oci_request(
         _ => {}
     }
 
-    let resp = req.send().await.map_err(SpmError::Http)?;
+    let resp = req.send().await.map_err(|e| SpmError::Http(Arc::new(e)))?;
     let status = resp.status();
     if status.is_success() {
         Ok(resp)
diff --git a/spm-core/src/fetch/validation.rs b/spm-core/src/fetch/validation.rs
index fdfd1a6..c8691c1 100644
--- a/spm-core/src/fetch/validation.rs
+++ b/spm-core/src/fetch/validation.rs
@@ -10,31 +10,17 @@ use crate::utils::error::{Result, SpmError};
 
 pub fn verify_checksum(path: &Path, expected: &str) -> Result<()> {
     tracing::debug!("Verifying checksum for: {}", path.display());
-    let mut file = File::open(path).map_err(|e| {
-        SpmError::Io(io::Error::new(
-            e.kind(),
-            format!("Failed to open file for checksum {}: {}", path.display(), e),
-        ))
-    })?;
-
+    let mut file = File::open(path)?;
     let mut hasher = Sha256::new();
-    let bytes_copied = io::copy(&mut file, &mut hasher).map_err(|e| {
-        SpmError::Io(io::Error::new(
-            e.kind(),
-            format!("Failed read file for checksum {}: {}", path.display(), e),
-        ))
-    })?;
-
+    let bytes_copied = io::copy(&mut file, &mut hasher)?;
     let hash_bytes = hasher.finalize();
     let actual = hex::encode(hash_bytes);
-
     tracing::debug!(
         "Calculated SHA256: {} ({} bytes read)",
         actual,
         bytes_copied
     );
     tracing::debug!("Expected SHA256:   {}", expected);
-
     if actual.eq_ignore_ascii_case(expected) {
         Ok(())
     } else {
@@ -49,54 +35,43 @@ pub fn verify_checksum(path: &Path, expected: &str) -> Result<()> {
 
 /// Verifies that the detected content type of the file matches the expected extension.
 pub fn verify_content_type(path: &Path, expected_ext: &str) -> Result<()> {
-    match infer::get_from_path(path) {
-        Ok(Some(kind)) => {
-            let actual_ext = kind.extension();
-            // Normalize extensions (e.g., tgz -> gz) if necessary based on `infer` behavior
-            // For now, direct comparison:
-            if actual_ext.eq_ignore_ascii_case(expected_ext) {
-                tracing::debug!(
-                    "Content type verified: {} matches expected {}",
-                    actual_ext,
-                    expected_ext
-                );
-                Ok(())
-            } else {
-                Err(SpmError::Generic(format!(
-                    // Consider a specific SpmError::ValidationError
-                    "Content type mismatch for {}: expected extension '{}', but detected '{}'",
-                    path.display(),
-                    expected_ext,
-                    actual_ext
-                )))
-            }
+    let kind_opt = infer::get_from_path(path)?;
+    if let Some(kind) = kind_opt {
+        let actual_ext = kind.extension();
+        if actual_ext.eq_ignore_ascii_case(expected_ext) {
+            tracing::debug!(
+                "Content type verified: {} matches expected {}",
+                actual_ext,
+                expected_ext
+            );
+            Ok(())
+        } else {
+            Err(SpmError::Generic(format!(
+                "Content type mismatch for {}: expected extension '{}', but detected '{}'",
+                path.display(),
+                expected_ext,
+                actual_ext
+            )))
         }
-        Ok(None) => Err(SpmError::Generic(format!(
+    } else {
+        Err(SpmError::Generic(format!(
             "Could not determine content type for {}",
             path.display()
-        ))),
-        Err(e) => Err(SpmError::Io(e)), // Propagate IO error
+        )))
     }
 }
 
 /// Validates a URL, ensuring it uses the HTTPS scheme.
 pub fn validate_url(url_str: &str) -> Result<()> {
-    match Url::parse(url_str) {
-        Ok(url) => {
-            if url.scheme() == "https" {
-                Ok(())
-            } else {
-                Err(SpmError::ValidationError(format!(
-                    // Consider SpmError::ValidationError
-                    "Invalid URL scheme for '{}': Must be https, but got '{}'",
-                    url_str,
-                    url.scheme()
-                )))
-            }
-        }
-        Err(e) => Err(SpmError::Generic(format!(
-            // Consider SpmError::ValidationError
-            "Failed to parse URL '{url_str}': {e}"
-        ))),
+    let url = Url::parse(url_str)
+        .map_err(|e| SpmError::Generic(format!("Failed to parse URL '{url_str}': {e}")))?;
+    if url.scheme() == "https" {
+        Ok(())
+    } else {
+        Err(SpmError::ValidationError(format!(
+            "Invalid URL scheme for '{}': Must be https, but got '{}'",
+            url_str,
+            url.scheme()
+        )))
     }
 }
diff --git a/spm-core/src/keg.rs b/spm-core/src/keg.rs
index 04ca874..c55264e 100644
--- a/spm-core/src/keg.rs
+++ b/spm-core/src/keg.rs
@@ -1,24 +1,24 @@
 use std::fs;
 use std::path::{Path, PathBuf};
 
-use semver::Version; // Changed from crate::model::version::Version
+use semver::Version;
 
 use crate::utils::config::Config;
-use crate::utils::error::{Result, SpmError};
+use crate::utils::error::Result;
 
 /// Represents information about an installed package (Keg).
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub struct InstalledKeg {
     pub name: String,
-    pub version: Version, // Use semver::Version
-    pub path: PathBuf,    // Path to the versioned installation directory (e.g., Cellar/foo/1.2.3)
-    pub revision: u32,    // Store revision separately
+    pub version: Version,
+    pub path: PathBuf,
+    pub revision: u32,
 }
 
 /// Manages querying installed packages in the Cellar.
 #[derive(Debug)]
 pub struct KegRegistry {
-    config: Config, // Holds paths like cellar and prefix
+    config: Config,
 }
 
 impl KegRegistry {
@@ -48,13 +48,12 @@ impl KegRegistry {
 
         let mut latest_keg: Option<InstalledKeg> = None;
 
-        for entry_result in fs::read_dir(&formula_dir).map_err(SpmError::Io)? {
-            let entry = entry_result.map_err(SpmError::Io)?;
+        for entry_result in fs::read_dir(&formula_dir)? {
+            let entry = entry_result?;
             let path = entry.path();
 
             if path.is_dir() {
                 if let Some(version_str_full) = path.file_name().and_then(|n| n.to_str()) {
-                    // Separate version and revision
                     let mut parts = version_str_full.splitn(2, '_');
                     let version_part = parts.next().unwrap_or(version_str_full);
                     let revision = parts
@@ -62,7 +61,6 @@ impl KegRegistry {
                         .and_then(|s| s.parse::<u32>().ok())
                         .unwrap_or(0);
 
-                    // Attempt to parse the version part (pad if necessary)
                     let version_str_padded = if version_part.split('.').count() < 3 {
                         let v_parts: Vec<&str> = version_part.split('.').collect();
                         match v_parts.len() {
@@ -82,7 +80,6 @@ impl KegRegistry {
                             path: path.clone(),
                         };
 
-                        // Compare with the latest found so far
                         match latest_keg {
                             Some(ref latest) => {
                                 if version > latest.version
@@ -96,7 +93,6 @@ impl KegRegistry {
                             }
                         }
                     }
-                    // else: Ignore directories that don't parse as versions
                 }
             }
         }
@@ -106,32 +102,28 @@ impl KegRegistry {
 
     /// Lists all installed kegs.
     /// Reads the cellar directory and parses all valid keg structures found.
-    // Ensure this method is public
     pub fn list_installed_kegs(&self) -> Result<Vec<InstalledKeg>> {
         let mut installed_kegs = Vec::new();
         let cellar_dir = self.cellar_path();
 
         if !cellar_dir.is_dir() {
-            return Ok(installed_kegs); // Cellar doesn't exist
+            return Ok(installed_kegs);
         }
 
-        // Iterate over formula name directories
-        for formula_entry_res in fs::read_dir(cellar_dir).map_err(SpmError::Io)? {
-            let formula_entry = formula_entry_res.map_err(SpmError::Io)?;
+        for formula_entry in fs::read_dir(cellar_dir)? {
+            let formula_entry = formula_entry?;
             let formula_path = formula_entry.path();
 
             if formula_path.is_dir() {
                 if let Some(formula_name) = formula_path.file_name().and_then(|n| n.to_str()) {
-                    // Iterate over version directories within the formula dir
-                    for version_entry_res in fs::read_dir(&formula_path).map_err(SpmError::Io)? {
-                        let version_entry = version_entry_res.map_err(SpmError::Io)?;
+                    for version_entry in fs::read_dir(&formula_path)? {
+                        let version_entry = version_entry?;
                         let version_path = version_entry.path();
 
                         if version_path.is_dir() {
                             if let Some(version_str_full) =
                                 version_path.file_name().and_then(|n| n.to_str())
                             {
-                                // Parse version and revision
                                 let mut parts = version_str_full.splitn(2, '_');
                                 let version_part = parts.next().unwrap_or(version_str_full);
                                 let revision = parts
@@ -172,7 +164,7 @@ impl KegRegistry {
         &self.config.cellar
     }
 
-    /// Returns the path for a *specific* versioned keg (whether installed or not).
+    /// Returns the path for a specific versioned keg (whether installed or not).
     /// Includes revision in the path name if revision > 0.
     pub fn get_keg_path(&self, name: &str, version: &Version, revision: u32) -> PathBuf {
         let version_string = if revision > 0 {
diff --git a/spm-core/src/utils/cache.rs b/spm-core/src/utils/cache.rs
index d4f5120..ded1a93 100644
--- a/spm-core/src/utils/cache.rs
+++ b/spm-core/src/utils/cache.rs
@@ -25,7 +25,7 @@ pub struct Cache {
 impl Cache {
     pub fn new(cache_dir: &Path) -> Result<Self> {
         if !cache_dir.exists() {
-            fs::create_dir_all(cache_dir).map_err(SpmError::Io)?; // Replaced closure
+            fs::create_dir_all(cache_dir)?;
         }
 
         Ok(Self {
@@ -42,7 +42,7 @@ impl Cache {
     pub fn store_raw(&self, filename: &str, data: &str) -> Result<()> {
         let path = self.cache_dir.join(filename);
         tracing::debug!("Saving raw data to cache file: {:?}", path);
-        fs::write(&path, data).map_err(SpmError::Io)?;
+        fs::write(&path, data)?;
         Ok(())
     }
 
@@ -57,7 +57,7 @@ impl Cache {
             )));
         }
 
-        fs::read_to_string(&path).map_err(SpmError::Io)
+        fs::read_to_string(&path).map_err(|e| SpmError::Cache(format!("IO error: {e}")))
     }
 
     /// Checks if a cache file exists and is valid (within TTL)
@@ -80,7 +80,7 @@ impl Cache {
     pub fn clear_file(&self, filename: &str) -> Result<()> {
         let path = self.cache_dir.join(filename);
         if path.exists() {
-            fs::remove_file(&path).map_err(SpmError::Io)?;
+            fs::remove_file(&path)?;
         }
         Ok(())
     }
@@ -88,8 +88,8 @@ impl Cache {
     /// Clears all cache files
     pub fn clear_all(&self) -> Result<()> {
         if self.cache_dir.exists() {
-            fs::remove_dir_all(&self.cache_dir).map_err(SpmError::Io)?;
-            fs::create_dir_all(&self.cache_dir).map_err(SpmError::Io)?;
+            fs::remove_dir_all(&self.cache_dir)?;
+            fs::create_dir_all(&self.cache_dir)?;
         }
         Ok(())
     }
@@ -104,11 +104,7 @@ pub fn get_cache_dir() -> Result<PathBuf> {
 
     if !app_cache_dir.exists() {
         tracing::debug!("Creating cache directory at {:?}", app_cache_dir);
-        fs::create_dir_all(&app_cache_dir).map_err(|e| {
-            SpmError::Io(e)
-            // Consider a specific Cache error variant: Cache(format!("Failed to create cache dir:
-            // {}", e))
-        })?;
+        fs::create_dir_all(&app_cache_dir)?;
     }
     Ok(app_cache_dir)
 }
diff --git a/spm-core/src/utils/error.rs b/spm-core/src/utils/error.rs
index 66f5bcc..00129cf 100644
--- a/spm-core/src/utils/error.rs
+++ b/spm-core/src/utils/error.rs
@@ -1,19 +1,23 @@
-// spm-core/src/utils/error.rs
-// *** Added MachO related error variants *** [cite: 142]
+use std::sync::Arc;
 
 use thiserror::Error;
 
-// Define a top-level error enum for the application using thiserror
-#[derive(Error, Debug)]
+#[derive(Error, Debug, Clone)]
 pub enum SpmError {
     #[error("I/O Error: {0}")]
-    Io(#[from] std::io::Error),
+    Io(#[from] Arc<std::io::Error>),
 
     #[error("HTTP Request Error: {0}")]
-    Http(#[from] reqwest::Error),
+    Http(#[from] Arc<reqwest::Error>),
 
     #[error("JSON Parsing Error: {0}")]
-    Json(#[from] serde_json::Error),
+    Json(#[from] Arc<serde_json::Error>),
+
+    #[error("Semantic Versioning Error: {0}")]
+    SemVer(#[from] Arc<semver::Error>),
+
+    #[error("Object File Error: {0}")]
+    Object(#[from] Arc<object::read::Error>),
 
     #[error("Configuration Error: {0}")]
     Config(String),
@@ -24,12 +28,8 @@ pub enum SpmError {
     #[error("API Request Error: {0}")]
     ApiRequestError(String),
 
-    #[error("Semantic Versioning Error: {0}")]
-    SemVer(#[from] semver::Error),
-
-    // Updated DownloadError to match previous structure if needed, or keep simple
     #[error("DownloadError: Failed to download '{0}' from '{1}': {2}")]
-    DownloadError(String, String, String), // name, url, reason
+    DownloadError(String, String, String),
 
     #[error("Cache Error: {0}")]
     Cache(String),
@@ -43,12 +43,11 @@ pub enum SpmError {
     #[error("Generic Error: {0}")]
     Generic(String),
 
-    // Keep HttpError if distinct from Http(reqwest::Error) is needed
     #[error("HttpError: {0}")]
     HttpError(String),
 
     #[error("Checksum Mismatch: {0}")]
-    ChecksumMismatch(String), // Keep if used distinctly from ChecksumError
+    ChecksumMismatch(String),
 
     #[error("Validation Error: {0}")]
     ValidationError(String),
@@ -68,31 +67,53 @@ pub enum SpmError {
     #[error("Build environment setup failed: {0}")]
     BuildEnvError(String),
 
-    // Kept IoError if distinct from Io(std::io::Error) is useful
     #[error("IoError: {0}")]
     IoError(String),
 
     #[error("Failed to execute command: {0}")]
     CommandExecError(String),
 
-    // --- Added Mach-O Relocation Errors (Based on Plan) --- [cite: 142]
     #[error("Mach-O Error: {0}")]
-    MachOError(String), // General Mach-O processing error
+    MachOError(String),
 
     #[error("Mach-O Modification Error: {0}")]
-    MachOModificationError(String), // Specific error during modification step
+    MachOModificationError(String),
 
     #[error("Mach-O Relocation Error: Path too long - {0}")]
-    PathTooLongError(String), /* Specifically for path length issues during patching [cite:
-                               * 115, 142] */
+    PathTooLongError(String),
 
     #[error("Codesign Error: {0}")]
-    CodesignError(String), // For errors during re-signing on Apple Silicon [cite: 138, 142]
+    CodesignError(String),
+}
 
-    // --- Added object crate error integration --- [cite: 142]
-    #[error("Object File Error: {0}")]
-    Object(#[from] object::read::Error), // Error from object crate parsing
+impl From<std::io::Error> for SpmError {
+    fn from(err: std::io::Error) -> Self {
+        SpmError::Io(Arc::new(err))
+    }
+}
+
+impl From<reqwest::Error> for SpmError {
+    fn from(err: reqwest::Error) -> Self {
+        SpmError::Http(Arc::new(err))
+    }
+}
+
+impl From<serde_json::Error> for SpmError {
+    fn from(err: serde_json::Error) -> Self {
+        SpmError::Json(Arc::new(err))
+    }
+}
+
+impl From<semver::Error> for SpmError {
+    fn from(err: semver::Error) -> Self {
+        SpmError::SemVer(Arc::new(err))
+    }
+}
+
+impl From<object::read::Error> for SpmError {
+    fn from(err: object::read::Error) -> Self {
+        SpmError::Object(Arc::new(err))
+    }
 }
 
-// Define a convenience Result type alias using our custom error
 pub type Result<T> = std::result::Result<T, SpmError>;
